package main.sintactico;

import java_cup.runtime.*;
import main.lexico.AnalizadorLexicoJaja;
import main.lexico.UnidadLexica;
import main.errors.GestionErroresJaja;

scan with {: return getScanner().next_token(); :};
parser code {: 
    private GestionErroresJaja errores;
    public void syntax_error(Symbol unidadLexica) {
        errores.errorSintactico((UnidadLexica) unidadLexica);
    }
:};

init with {: 
    errores = new GestionErroresJaja();
    AnalizadorLexicoJaja alex = (AnalizadorLexicoJaja) getScanner();
    alex.fijaGestionErrores(errores);
:};


terminal    //Palabras clave
            ENT, BIN, FACTO, FAKE, SI, SINO, MIENTRAS, PARA, DIVER, REGISTRO,
            NULO, INCOGNITO, DEVUELVE, TRAFICAR, COMO,

            //Variables
            ID, ENTERO,

            //Operadores Aritmeticos
            POT, MUL, DIV, MOD, SUMA, RESTA,

            //Relacionales
            IGUAL, DESIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL,

            //Logicos
            NEG, CONJ, DISY,

            //Otros
            DIRECCION, PUNTERO, ASIGNACION, PUNTO, COMA, PUNTOCOMA, DOSPUNTOS, FLECHA,

            //Agrupaciones
            CAP, CCIERRE, PAP, PCIERRE, LLAP, LLCIERRE;






/////////////////////
///Inicio programa///
/////////////////////
Programa ::= Lista_Instrucciones: lInstrucciones
    {: RESULT = new Programa(lInstrucciones); :};

//Todas las instrucciones acaban en punto y coma
Lista_Instrucciones ::= Instruccion: ins PUNTOCOMA
    {: List<Instruccion> lInstrucciones = new ArrayList<Instruccion>();
    lInstrucciones.add(ins);
    RESULT = lInstrucciones; :};

                    | Lista_Instrucciones: lInstrucciones Instruccion: ins PUNTOCOMA
    {: lInstrucciones.add(ins);
    RESULT = lInstrucciones; :};

Instruccion ::= Declaracion: decl
    {: RESULT = decl; :}
            |   Asignacion: as
    {: RESULT = as; :}
            |   Decl_Asig: dAs
    {: RESULT = dAs; :}
            |   Alias: aka          //Also known as
    {: RESULT = aka; :}
            |   Condicional: cond
    {: RESULT = cond; :}
            |   Bucle: buc
    {: RESULT = buc; :}
            |   Inst_Return: iRet
    {: RESULT = iRet; :}
            ;



/////////////////////
///     TIPOS     ///
/////////////////////

Tipo ::= Tipo:tipo PUNTERO
    {: RESULT = new TipoPuntero(tipo); :}

Tipo ::= T:tipo
    {: RESULT = tipo; :}

T ::= ENT
    {: RESULT = new TipoEntero();  :}

    | BIN 
    {: RESULT = new TipoBinario(); :}

    | ID: id             //ID se referirá a los identificadores definidos por el incognito
    {: RESULT = new TipoAlias(id.getLexema(), id.getFila(), id.getColumna()); :}

    | Tipo_Reg: t_reg
    {: RESULT = t_reg; :}
    ;


Tipo_Reg ::= REGISTRO CAP Matriz_Atributos: mAtrib CCIERRE
    {: RESULT = new TipoRegistro(mAtrib); :}


//Una sola lista de atributos o varias con la coma de la última opcional
Matriz_Atributos ::= Lista_Atributos: lAtr
    {: List<List<Atributo>> mAtr = new ArrayList<List<Atributo>>();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Lista_Atributos: lAtr COMA
    {: List<List<Atributo>> mAtr = new ArrayList<List<Atributo>>();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr
    {: mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr COMA
    {: mAtr.add(lAtr); RESULT = mAtr; :}


Matriz_Atributos' ::= Lista_Atributos: lAtr COMA
    {: List<List<Atributo>> mAtr = new ArrayList<List<Atributo>>();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr COMA
    {: mAtr.add(lAtr); RESULT = mAtr; :}


//Iremos recorriendo cada variable para asignarle su correspondiente tipo
Lista_Atributos ::= Lista_Variables: lVar DOSPUNTOS Tipo: tipo
    {: RESULT = ast.listaAtributos(lVar, tipo); :}



Lista_Variables ::= Variable: var
    {: List<Variable> lVar = new ArrayList<Variable>();
    lVar.add(var); RESULT = lVar; :}

                | Lista_Variables': lVar Variable: var
    {: lVar.add(var); RESULT = lVar; :}

Lista_Variables' ::= Variable: var COMA
    {: List<Variable> lVar = new ArrayList<Variable>();
    lVar.add(var); RESULT = lVar; :}

                | Lista_Variables': lVar Variable: var COMA
    {: lVar.add(var); RESULT = lVar; :}



//El tipo de las variables se le puede dar después de construirlas
Variable ::= ID: id Lista_Corchetes: lCor
    {: RESULT = new Variable(id.lexema(), lCor)); :};


//El tipo array lo construimos al enlazarlo con el tipo
Lista_Corchetes ::= //Sin corchetes
    {: Result = new ArrayList<int>() :}

                | CAP ENTERO: num CCIERRE
    {: lCor = new ArrayList<int>() 
    lCor.add(num.lexema()); RESULT = lCor :}

                | Lista_Corchetes: lCor CAP ENTERO: num CCIERRE
    {: lCor.add(num.lexema()); RESULT = lCor :}




/////////////////////
////INSTRUCCIONES////
/////////////////////

///Declaraciones///
Declaracion ::= Dec_Variables: dec_var
    {: RESULT = dec_var :}

            | Dec_Funcion: dec_fun;
    {: RESULT = dec_fun :}
            ;


//Iremos recorriendo cada variable para asignarle su correspondiente tipo
Dec_Variables ::= Tipo: tipo Lista_Variables: lVar
    {: RESULT = ast.listaVariables(tipo, lVar); :}

Dec_Funcion ::= Dec_Funcion_Void: fVoid 
    {: RESULT = fVoid :}
            | Dec_Funcion_Ret: fReturn
    {: RESULT = fReturn :}

Dec_Funcion_Void ::= DIVER ID: id PAP Lista_Parametros: lPar PCIERRE Bloque_Anidado: bloq
    {: RESULT = new FuncionVoid(id.lexema(), lPar, bloq) :}

Dec_Funcion_Ret ::= DIVER ID: id PAP Lista_Parametros: lPAR PCIERRE FLECHA Tipo: t Bloque_Anidado: bloq
    {: RESULT = new FuncionRet(id.lexema(), lPar, bloq, t) :}


///Bloque anidado///
Bloque_Anidado ::= CAP Lista_Instrucciones: LIns CCIERRE
    {: RESULT = LIns :}


///Asignaciones///
Asignacion ::= Expresion: expr1 ASIGNACION Der_Asig: DAsig
    {: RESULT = new InsAsig(expr1, DAsig)  :}

Der_Asig ::= Expresion: ASimple
    {: RESULT = ASimple :}
    | Asig_Array: AArray
    {: RESULT = AArray :}
    | Asig_Struct: AStruct
    {: RESULT = AStruct :}


Asig_Array ::= CAP Lista_Expresiones: LExp CCIERRE
    {: RESULT = LExp :}

Lista_Expresiones ::= Expresion: exp
    {: List<Expresion> lExp = new ArrayList<Expresion>();
    lExp.add(exp); RESULT = lExp; :}

                | Lista_Expresiones': lExp Expresion: exp
    {: lExp.add(exp); RESULT = lExp; :}

Lista_Variables' ::= Variable: var COMA
    {: List<Variable> lVar = new ArrayList<Variable>();
    lVar.add(var); RESULT = lVar; :}

                | Lista_Variables': lVar Variable: var COMA
    {: lVar.add(var); RESULT = lVar; :}

Lista_Expresiones ::= Expresion: exp COMA
    {: List<Expresion> lExpresiones = new ArrayList<Expresion>();
    lExpresiones.add(exp);
    RESULT = lExpresiones; :};

                    | Lista_Expresiones: lExpresiones Expresion: exp COMA
    {: lExpresiones.add(exp);
    RESULT = lExpresiones; :};


Asig_Struct ::= LLAP Lista_Asignaciones: LAsig LLCIERRE
    {: RESULT = lAsig :}

Lista_Asignaciones ::= Asignacion: asig COMA
    {: List<Asignacion> lAsignaciones = new ArrayList<Asignacion>();
    lAsignaciones.add(asig);
    RESULT = lAsignaciones; :};

                    | Lista_Asignaciones: lAsignaciones Asignacion: asig COMA
    {: lAsignaciones.add(asig);
    RESULT = lAsignaciones; :};


///Declaracion asignación///
Decl_Asig ::= Tipo: t Lista_Decl_Asig

Lista_Decl_Asignaciones ::= Decl_Asig: decl_asig COMA
    {: List<DeclAsignacion> lDeclAsignaciones = new ArrayList<DeclAsignacion>();
    lDeclAsignaciones.add(decl_asig);
    RESULT = lDeclAsignaciones; :};

                    | Lista_Decl_Asignaciones: lDeclAsignaciones Decl_Asig: decl_asig COMA
    {: lDeclAsignaciones.add(decl_asig);
    RESULT = lDeclAsignaciones; :};

Decl_Asig ::= ID: id
    {: RESULT = new Variable() :}
    
    | ID: id ASIGNACION Der_Asig: DAsig
    {: Result = new Variable() :}
