package main.sintactico;

import java_cup.runtime.*;
import main.lexico.AnalizadorLexicoJaja;
import main.lexico.UnidadLexica;
import main.errors.GestionErroresJaja;

scan with {: return getScanner().next_token(); :};
parser code {: 
    private GestionErroresJaja errores;
    public void syntax_error(Symbol unidadLexica) {
        errores.errorSintactico((UnidadLexica) unidadLexica);
    }
:};

init with {: 
    errores = new GestionErroresJaja();
    AnalizadorLexicoJaja alex = (AnalizadorLexicoJaja) getScanner();
    alex.fijaGestionErrores(errores);
:};


terminal    //Palabras clave
            ENT, BIN, FACTO, FAKE, SI, SINO, MIENTRAS, PARA, DIVER, REGISTRO,
            NULO, INCOGNITO, DEVUELVE, TRAFICAR, COMO,

            //Variables
            ID, ENTERO,

            //Operadores Aritmeticos
            POT, MUL, DIV, MOD, SUMA, RESTA,

            //Relacionales
            IGUAL, DESIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL,

            //Logicos
            NEG, CONJ, DISY,

            //Otros
            DIRECCION, PUNTERO, ASIGNACION, PUNTO, COMA, PUNTOCOMA, DOSPUNTOS, FLECHA,

            //Agrupaciones
            CAP, CCIERRE, PAP, PCIERRE, LLAP, LLCIERRE;

non terminal programa, lista_instrucciones, instruccion ;

//Inicio
programa ::= lista_instrucciones;

lista_instrucciones ::= instruccion
                    |   lista_instrucciones instruccion;

instruccion ::= declaracion
            |   asignacion
            |   decl_asig
            |   condicional
            |   bucles
            |   inst_return
            ;

tipo ::= ENT | BIN | ID ;       //ID se referirÃ¡ a los identificadores definidos por el incognito


//Declaraciones
declaracion ::= declaracion_simple | declaracion_reg;

declaracion_simple ::= tipo lista_identificadores PUNTOCOMA;

lista_identificadores ::= ID parejas_corcs
                |   lista_identificadores COMA ID parejas_corcs
                ;

parejas_corcs ::= CAP CCIERRE parejas_corcs |  ;


declaracion_reg ::= REGISTRO LLAP lista_atributos LLCIERRE lista_identificadores PUNTOCOMA;

lista_atributos ::= lista_identificadores DOSPUNTOS tipo 
                | lista_identificadores DOSPUNTOS tipo COMA
                | lista_identificadores DOSPUNTOS tipo COMA lista_atributos
                ;


//Asignaciones
asignacion ::= ID asignacion_simple PUNTOCOMA | ID asignacion_array PUNTOCOMA | ID asignacion_reg PUNTOCOMA;

asignacion_simple ::= ASIGNACION expresion;

    //Arrays
asignacion_array ::= ASIGNACION CAP lista_expresiones_array CCIERRE
                 |   ASIGNACION tipo lista_parejas_corc_cont
                 ;

lista_expresiones_array ::= 
                        | expresion_array 
                        | lista_expresiones_array COMA expresion_array ;

//TODO: Se puede hacer esto (recursion mutua)?
expresion_array ::= expresion 
                |   CAP lista_expresiones_array CCIERRE ; 


lista_parejas_corc_cont ::= CAP ENTERO CCIERRE
                        |  lista_parejas_corc_cont CAP ENTERO CCIERRE ;


    //Registros
asignacion_reg ::= ASIGNACION LLAP lista_asignaciones LLCIERRE;

lista_asignaciones ::= asignacion
                   |   asignacion COMA
                   |   asignacion COMA lista_asignaciones ;


//Declaraciones Asignaciones
decl_asig ::= decl_asig_simple | decl_asig_array | decl_asig_reg ;

decl_asig_simple ::= tipo ID asignacion_simple;
decl_asig_array ::= tipo ID parejas_corcs asignacion_array;
decl_asig_reg ::= REGISTRO 


//Expresiones

file: [statements] EOF
interactive: statement_newline 
eval: expressions NEWLINE* ENDMARKER 
func_type: '(' [type_expressions] ')' '->' expression NEWLINE* ENDMARKER 
