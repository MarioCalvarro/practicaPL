package main.sintactico;

import java_cup.runtime.*;
import main.lexico.AnalizadorLexicoJaja;
import main.lexico.UnidadLexica;
import main.errors.GestionErroresJaja;

scan with {: return getScanner().next_token(); :};
parser code {: 
    private GestionErroresJaja errores;
    public void syntax_error(Symbol unidadLexica) {
        errores.errorSintactico((UnidadLexica) unidadLexica);
    }
:};

init with {: 
    errores = new GestionErroresJaja();
    AnalizadorLexicoJaja alex = (AnalizadorLexicoJaja) getScanner();
    alex.fijaGestionErrores(errores);
:};


terminal    //Palabras clave
            ENT, BIN, FACTO, FAKE, SI, SINO, MIENTRAS, PARA, DIVER, REGISTRO,
            NULO, INCOGNITO, DEVUELVE, TRAFICAR, COMO,

            //Variables
            ID, ENTERO,

            //Operadores Aritmeticos
            POT, MUL, DIV, MOD, SUMA, RESTA,

            //Relacionales
            IGUAL, DESIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL,

            //Logicos
            NEG, CONJ, DISY,

            //Otros
            DIRECCION, PUNTERO, ASIGNACION, PUNTO, COMA, PUNTOCOMA, DOSPUNTOS, FLECHA,

            //Agrupaciones
            CAP, CCIERRE, PAP, PCIERRE, LLAP, LLCIERRE;






/////////////////////
///Inicio programa///
/////////////////////
//El programa será las importaciones seguidas de declaraciones de funciones y
//variables (globales). Las instrucciones solo estarán en las funciones y el
//main será lo primero que se ejecute
Programa ::= Lista_Imports: lImp Lista_Declaraciones: lDecl
    {: RESULT = new Programa(lImp, lDecl); :};

Lista_Imports ::= Lista_Imports: lImp TRAFICAR ID: ruta COMO ID: id
    {: lImp.add(new Import(ruta))); RESULT = lImp; :}
              |
    {: RESULT = new ArrayList<Import>(); :}


Lista_Declaraciones ::= Lista_Declaraciones: lDecl Declaracion_Alias: dAlias
                      {: lDecl.add(dAlias); RESULT = lDecl; :}

                    //Variables o Funciones
                    | Lista_Declaraciones: lDecl Declaracion: dGen
                      {: lDecl.add(dGen); RESULT = lDecl; :}

                    //No lo hacemos directamente ArrayList porque tenemos que
                    //extender "add" para insertar una lista de variables con el
                    //mismo tipo
                    | 
                      {: RESULT = new ListaDeclaraciones(); :}

Declaracion_Alias ::= INCOGNITO ID: id ASIGNACION Tipo: t
    {: RESULT = new DeclaracionAlias(id, t); :}

///Declaraciones///
Declaracion ::= Decl_Variables: decl_var
    {: RESULT = decl_var; :}

            | Decl_Funcion: decl_fun;
    {: RESULT = decl_fun; :}
            ;


//Iremos recorriendo cada variable para asignarle su correspondiente tipo
Decl_Variables ::= Tipo: tipo Lista_Decl_Asignaciones: lVar
    {: RESULT = new DeclaracionVariables(tipo, lVar); :}


Lista_Decl_Asignaciones ::= Decl_Asig: var
        {: List<DeclaracionVar> lista_var = new ArrayList<DeclaracionVar>();
        lista_var.add(var); RESULT = lista_var; :};

                        | Lista_Decl_Asignaciones: lDecl COMA Decl_Asig: var
        {: lDecl.add(var); RESULT = lDecl; :};


Decl_Asig ::= Id: var
    {: RESULT = new DeclaracionVar(var); :}

          | Id: var ASIGNACION Expresion: expr2
    {: Result = new DeclaracionVar(var, expr2); :}


//Declaracion funciones
Dec_Funcion ::= DIVER ID: id PAP Lista_Parametros: lPar PCIERRE Bloque_Anidado: bloq        //Función que no devuelve nada 
    {: RESULT = new DeclaracionFun(id, lPar, bloq); :}
            | DIVER ID: id PAP Lista_Parametros: lPar PCIERRE FLECHA Tipo: t Bloque_Anidado: bloq   //Función con retorno
    {: RESULT = new DeclaracionFun(id, lPar, bloq, t) :}

Lista_Parametros ::= //Sin parámetros
    {: RESULT = new ArrayList<DeclaracionVar>(); :}
                 | Lista_Parametros': lPar      //Con uno o más
    {: RESULT = lPar; :}

Lista_Parametros' ::= Parametro: par
    {: List<DeclaracionVar> lista_par = new ArrayList<DeclaracionVar>();
    lista_par.add(par); RESULT = lista_par; :}
                  | Lista_Parametros': lPar FLECHA Parametro: par
    {: lPar.add(par); RESULT = lPar; :}


/////////////////////
////INSTRUCCIONES////
/////////////////////
///Bloque anidado///
Bloque_Anidado ::= CAP Lista_Instrucciones: LIns CCIERRE
    {: RESULT = LIns :}

Lista_Instrucciones ::= Instruccion: ins
    {: List<Instruccion> lInstrucciones = new ArrayList<Instruccion>();
    lInstrucciones.add(ins);
    RESULT = lInstrucciones; :};

                    | Lista_Instrucciones: lInstrucciones Instruccion: ins
    {: lInstrucciones.add(ins);
    RESULT = lInstrucciones; :};


///Tipos de instrucciones///
Instruccion ::= Dec_Variables: decl PUNTOCOMA       //Solo la declaracion de variables (no dejamos que se puedan definir funciones dentro de otras)
    {: RESULT = decl; :}
            |   Asignacion: as PUNTOCOMA
    {: RESULT = as; :}
            |   Expresion: exp PUNTOCOMA        //Llamadas a funcion
    {: RESULT = exp; :}
            |   Condicional: cond
    {: RESULT = cond; :}
            |   Bucle: buc
    {: RESULT = buc; :}
            |   Inst_Return: iRet PUNTOCOMA
    {: RESULT = iRet; :}


///Asignaciones///
Asignacion ::= Expresion: expr1 ASIGNACION Expresion: expr2
    {: RESULT = new InsAsig(expr1, expr2);  :};


/////////////////////
///     TIPOS     ///
/////////////////////
Tipo ::= Tipo: tipo PUNTERO
    {: RESULT = new TipoPuntero(tipo); :}

//Leemos todos los corchetes a la vez para evitar que las dimensiones esten
//invertidas (en java se construirán el tipo correctamente)
        | Tipo: tipo Lista_Dimensiones: lDim
    {: RESULT = new TipoArray(tipo, lDim); :}

        | T: tipo
    {: RESULT = tipo; :}

T ::= ENT
    {: RESULT = new TipoEntero();  :}

    | BIN 
    {: RESULT = new TipoBinario(); :}

    | ID: id             //ID se referirá a los identificadores definidos por el incognito
    {: RESULT = new TipoAlias(); :}

    | Tipo_Reg: t_reg
    {: RESULT = t_reg; :}
    ;

//Arrays
Lista_Dimensiones ::= CAP Entero: dim CCIERRE
    {: RESULT = new ArrayList<Integer>(dim); :}

                  | Lista_Dimensiones: lDim CAP ENTERO: dim CCIERRE
    {: lDim.add(dim); RESULT = lDim; :}


//Registros
Tipo_Reg ::= REGISTRO CAP Matriz_Atributos: mAtrib CCIERRE
    {: RESULT = new TipoRegistro(mAtrib); :}


//Una sola lista de atributos o varias con la coma de la última opcional
Matriz_Atributos ::= Lista_Atributos: lAtr
    {: ListaDeclaraciones mAtr = new ListaDeclaraciones();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Lista_Atributos: lAtr COMA
    {: ListaDeclaraciones mAtr = new ListaDeclaraciones();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr
    {: mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr COMA
    {: mAtr.add(lAtr); RESULT = mAtr; :}


Matriz_Atributos' ::= Lista_Atributos: lAtr COMA
    {: ListaDeclaraciones mAtr = new ListaDeclaraciones();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr COMA
    {: mAtr.add(lAtr); RESULT = mAtr; :}


//Iremos recorriendo cada variable para asignarle su correspondiente tipo
//Pueden tener un valor por defecto
Lista_Atributos ::= Lista_Decl_Asignaciones: lVar DOSPUNTOS Tipo: tipo
    {: RESULT = new DeclaracionVariables(tipo, lVar); :}
