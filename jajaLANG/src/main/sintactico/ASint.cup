package main.sintactico;

import java_cup.runtime.*;
import main.lexico.AnalizadorLexicoJaja;
import main.lexico.UnidadLexica;
import main.errors.GestionErroresJaja;

scan with {: return getScanner().next_token(); :};
parser code {: 
    private GestionErroresJaja errores;
    public void syntax_error(Symbol unidadLexica) {
        errores.errorSintactico((UnidadLexica) unidadLexica);
    }
:};

init with {: 
    errores = new GestionErroresJaja();
    AnalizadorLexicoJaja alex = (AnalizadorLexicoJaja) getScanner();
    alex.fijaGestionErrores(errores);
:};


terminal    //Palabras clave
            ENT, BIN, FACTO, FAKE, SI, SINO, MIENTRAS, PARA, DIVER, REGISTRO,
            NULO, INCOGNITO, DEVUELVE, TRAFICAR, COMO,

            //Variables
            ID, ENTERO,

            //Operadores Aritmeticos
            POT, MUL, DIV, MOD, SUMA, RESTA,

            //Relacionales
            IGUAL, DESIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL,

            //Logicos
            NEG, CONJ, DISY,

            //Otros
            DIRECCION, PUNTERO, ASIGNACION, PUNTO, COMA, PUNTOCOMA, DOSPUNTOS, FLECHA,

            //Agrupaciones
            CAP, CCIERRE, PAP, PCIERRE, LLAP, LLCIERRE;






/////////////////////
///Inicio programa///
/////////////////////
Programa ::= Lista_Instrucciones: lInstrucciones
    {: RESULT = new Programa(lInstrucciones); :};

Lista_Instrucciones ::= Instruccion: ins PUNTOCOMA
    {: List<Instruccion> lInstrucciones = new ArrayList<Instruccion>();
    lInstrucciones.add(ins);
    RESULT = lInstrucciones; :}

                    | Lista_Instrucciones: lInstrucciones Instruccion: ins PUNTOCOMA
    {: lInstrucciones.add(ins);
    RESULT = lInstrucciones; :};

Instruccion ::= Declaracion: decl
    {: RESULT = decl; :}
            |   Asignacion: as
    {: RESULT = as; :}
            |   Decl_asig: dAs
    {: RESULT = dAs; :}
            |   Llamada_fun: llamada
    {: RESULT = llamada; :}
            |   Alias: aka          //Also known as
    {: RESULT = aka; :}
            |   Condicional: cond
    {: RESULT = cond; :}
            |   Bucle: buc
    {: RESULT = buc; :}
            |   Inst_return: iRet
    {: RESULT = iRet; :}
            ;



/////////////////////
///     TIPOS     ///
/////////////////////

Tipo ::= Tipo:tipo PUNTERO
    {: RESULT = new TipoPuntero(tipo); :};

Tipo ::= T:tipo
   {: RESULT = tipo; :};

T ::= ENT 
    {: RESULT = new TipoEntero();  :}

    | BIN 
    {: RESULT = new TipoBinario(); :}

    | ID: id             //ID se referirá a los identificadores definidos por el incognito
    {: RESULT = new TipoAlias(id.getLexema(), id.getFila(), id.getColumna()); :}

    | Tipo_Reg: t_reg
    {: RESULT = t_reg; :}
    ;


Tipo_Reg ::= REGISTRO LLAP Matriz_Atributos: mAtrib LLCIERRE
    {: RESULT = new TipoRegistro(mAtrib); :};


//Una sola lista de atributos o varias con la coma de la última opcional
Matriz_Atributos ::= Lista_Atributos: lAtr
    {: List<List<Atributo>> mAtr = new ArrayList<List<Atributo>>();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Lista_Atributos: lAtr COMA
    {: List<List<Atributo>> mAtr = new ArrayList<List<Atributo>>();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr
    {: mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr COMA
    {: mAtr.add(lAtr); RESULT = mAtr; :};


Matriz_Atributos' ::= Lista_Atributos: lAtr COMA
    {: List<List<Atributo>> mAtr = new ArrayList<List<Atributo>>();
    mAtr.add(lAtr); RESULT = mAtr; :}

                | Matriz_Atributos': mAtr Lista_Atributos: lAtr COMA
    {: mAtr.add(lAtr); RESULT = mAtr; :};


//Iremos recorriendo cada variable para asignarle su correspondiente tipo
Lista_Atributos ::= Lista_Variables: lVar DOSPUNTOS Tipo: tipo
    {: RESULT = ast.listaAtributos(lVar, tipo); :};



Lista_Variables ::= Variable: var
    {: List<Variable> lVar = new ArrayList<Variable>();
    lVar.add(var); RESULT = lVar; :}

                | Lista_Variables': lVar Variable: var
    {: lVar.add(var); RESULT = lVar; :};

Lista_Variables' ::= Variable: var COMA
    {: List<Variable> lVar = new ArrayList<Variable>();
    lVar.add(var); RESULT = lVar; :}

                | Lista_Variables': lVar Variable: var COMA
    {: lVar.add(var); RESULT = lVar; :};



//El tipo de las variables se le puede dar después de construirlas
Variable ::= ID: id Lista_Corchetes: lCor
    {: RESULT = new Variable(id.lexema(), lCor); :};


//El tipo array lo construimos al enlazarlo con el tipo
Lista_Corchetes ::= //Sin corchetes
    {: Result = new ArrayList<int>(); :}

                | CAP ENTERO: num CCIERRE
    {: lCor = new ArrayList<int>() 
    lCor.add(num.lexema()); RESULT = lCor; :}

                | Lista_Corchetes: lCor CAP ENTERO: num CCIERRE
    {: lCor.add(num.lexema()); RESULT = lCor; :};




/////////////////////
////INSTRUCCIONES////
/////////////////////

///Declaraciones///
Declaracion ::= Dec_variables: dec_var
    {: RESULT = dec_var; :}

            | Dec_funcion: dec_fun;
    {: RESULT = dec_fun; :}
            ;


//Iremos recorriendo cada variable para asignarle su correspondiente tipo
Dec_variables ::= Tipo: tipo Lista_Variables: lVar
    {: RESULT = ast.listaVariables(tipo, lVar); :};

Dec_funcion ::= Dec_funcion_void: fVoid 
    {: RESULT = fVoid; :}
            | Dec_funcion_ret: fReturn
    {: RESULT = fReturn; :};

Dec_funcion_void ::= DIVER ID: id PAP Lista_Parametros: lPar PCIERRE Bloque_Anidado: bloq
    {: RESULT = new FuncionVoid(id.lexema(), lPar, bloq); :};

Dec_funcion_ret ::= DIVER ID: id PAP Lista_Parametros: lPAR PCIERRE FLECHA Tipo: t Bloque_Anidado: bloq
    {: RESULT = new FuncionRet(id.lexema(), lPar, bloq, t); :};
    
    
    
///////////////////
////OPERACIONES////
///////////////////


//disyuncion
Expresion ::= Expresion: izquierda DISY E1: derecha
	{: RESULT = new OperadorBin(OperadorBin.Operadores.DISY, izquierda, derecha); :}
		  | E1: e1
	{: RESULT = e1; :};
		  
//conjunción 
E1 ::= E1: izquierda CONJ E2: dercha
	{: RESULT = new OperadorBin(OperadorBin.Operadores.CONJ, izquierda, derecha); :}
   | E2: e2
   	{: RESULT = e2; :};

//igual o desigual
E2 ::= E2:izquierda  OP2:op2 E3: derecha
	{: RESULT = new OperadorBin(op2, izquierda, derecha); :}
   | E3: e3
   	{: RESULT = e3; :};
   
OP2 ::= DESIGUAL
	{: RESULT = OperadorBin.Operadores.DESIGUAL; :}
   | IGUAL
   	{: RESULT = OperadorBin.Operadores.IGUAL; :};

//mayor, menor, mayorigual, menorigual
E3 ::= E3: izquierda OP3:op3 E4: derecha
    {: RESULT = new OperadorBin(op3, izquierda, derecha); :}
   | E4: e4
    {: RESULT = e4; :};
   
OP3 ::= MAYOR
	{: RESULT = OperadorBin.Operadores.MAYOR; :}
	 | MENOR
	{: RESULT = OperadorBin.Operadores.MENOR; :} 
	 | MAYORIGUAL
	{: RESULT = OperadorBin.Operadores.MAYORIGUAL; :}
	 | MENORIGUAL
	{: RESULT = OperadorBin.Operadores.MENORIGUAL; :};

//suma, resta
E4 ::= E4: izquierda OP4:op4 E5: derecha
    {: RESULT = new OperadorBin(op4, izquierda, derecha); :}
   | E5: e5
    {: RESULT = e5; :};
   
OP4 ::= SUMA
    {: RESULT = OperadorBin.Operadores.SUMA; :}	 
    | RESTA
    {: RESULT = OperadorBin.Operadores.RESTA; :};

//multiplicación, división, módulo
E5 ::= E5: izquierda OP5:op5 E6: derecha
    {: RESULT = new OperadorBin(op5, izquierda, derecha); :}
   | E6: e6
    {: RESULT = e6; :};
   
OP5 ::= MUL
    {: RESULT = OperadorBin.Operadores.MUL; :}	 
 	 | DIV
	{: RESULT = OperadorBin.Operadores.DIV; :}	 
	 | MOD
	{: RESULT = OperadorBin.Operadores.MOD; :}; 


//potencia
E6 ::= E6: izquierda POT E7: derecha
    {: RESULT = new OperadorBin(OperadorBin.POT, izquierda, derecha); :}
   | E7: e7
    {: RESULT = e7; :};

//dirección, puntero
E7 ::= E7: izquierda OP7:op7 E8: derecha
    {: RESULT = new OperadorBin(op7, izquierda, derecha); :}
   | E8: e8
    {: RESULT = e8; :};

   
OP7 ::= DIRECCION
    {: RESULT = OperadorBin.Operadores.DIRECCION; :}	 	 
    | PUNTERO
    {: RESULT = OperadorBin.Operadores.PUNTERO; :};

//negación
E8 ::= NEG E8: e8
    {: RESULT = new OperadorUn(OperadorUn.NEG, e8); :}
   | E9: e9
    {: RESULT = e9; :};

//corchete, punto
E9 ::= E9: izquierda CAP Expresion:derecha CCIERRE
    {: RESULT = new OperadorBin(OperadorBin.CORCHETE, izquierda, derecha); :}
   | E9: izquierda PUNTO E10: derecha
    {: RESULT = new OperadorBin(OperadorBin.PUNTO, izquierda, derecha); :}
   | E10: e10
    {: RESULT = e10; :};

//paréntesis
E10 ::= E10: izquierda PAP Expresion: derecha PCIERRE 
    {: RESULT = new OperadorBin(OperadorBin.PARENTESIS, izquierda, derecha); :}
   | E10: e10 PAP PCIERRE
    {: RESULT = e10; :};
	



    
