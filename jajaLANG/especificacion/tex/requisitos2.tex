El usuario podrá definir sus propios tipos haciendo un alias de tipos
compuestos (registros o arrays). La estructura para realizar un alias será la
siguiente: la palabra clave «incognito» seguido del alias y un igual. Tras esto,
se escribirá la expresión que se abrevia. Por ejemplo:
\begin{figure}[H]
    \centering
    \begin{lstlisting}
incognito matriz = ent[][];
    \end{lstlisting}
    \caption{Ejemplo de uso del alias.}
\end{figure}

\section*{Conjunto de instrucciones del lenguaje}
En nuestro lenguaje habrá presentes multitud de instrucciones de asignación
dependiendo del tipo de la variable (simples, arrays o registros). Todas ellas
tendrán en común el uso del operador igual (=) y la siguiente estructura: en el
lado izquierdo de la asignación tendremos una declaración de una variable o su
identificador y en el derecho una expresión con un valor. Las expresiones
posibles son las aritméticas y booleanas habituales (con los operadores
anteriormente definidos), pero también hemos decidido incorporar el operador
ternario (?) que evalúa una condición y dependiendo de esto asigna un valor u
otro (que vienen dados, a su vez, por expresiones). 

Los arrays serán asignados elemento a elemento, separando los valores dados por
comas y todo ello entre corchetes. Por otro lado, los registros se asignarán
valor a valor, pero de manera recursiva, cada campo individualmente. Por último,
las asignaciones pueden combinarse con operadores para realizarse sobre sí
mismas. Para asignar a un array una cantidad de memoria sin inicializar
simplemente escribimos el tipo de los elementos seguido de, entre corchetes, el
número de elementos. Para los registros inicializados sin valor inicial
simplemente escribimos el tipo del registro. Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
ent a = 5;
a = cond? 3 - 1 : 2 + 2;    //Si se cumple, 2. En caso contrario, 4
a += 5;                     //a = a + 5

bin b = true;
bin c = !b;
c |= b                      //c = b || c

ent arr1[] = [2, 3, 4];
arr1 = [3, 2, 1];
ent arr2[] = ent[3];        //Array de size 3, pero sin valores

registro datos reg1 = {a = 2 + 1, b = cond? true : b || c,};
reg1 = registro datos       //Reservar espacio nuevo
    \end{lstlisting}
    \caption{Ejemplos de asignaciones.}
\end{figure}

La ejecución condicional en este lenguaje tendrá como palabras claves «si» y
«sino». Estos condicionales tendrán $n$ ramas siguiendo la siguiente estructura:
empezamos con la palabra clave «si» seguida de una expresión condicional que se
evalúa a un «binario» y un bloque anidado de código (que se ejecutará si el
«binario» se evalúa a $1$. Tras esto, le seguirán $n$ bloques que empezarán con
la palabra clave «sino» y, opcionalmente, una condición y su correspondiente
bloque anidado de código. Si no existe condición, se interpretará como un «en
caso contrario» y se ejecutará si lo anteriores no lo han hecho. Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
si true || false || (3 != 2) {
    //Codigo
} sino false && true {
    //Codigo
} sino {
    //Codigo
}
    \end{lstlisting}
    \caption{Ejemplo de la ejecución condicional.}
\end{figure}

Hemos decidido incluir dos tipos de bucles que nombramos por «mientras» y «para»
(provenientes de \textit{while} y \textit{for}). La sintaxis que sigue
«mientras» es: palabra clave seguida de una expresión condicional y el bloque de
código que se ejecuta mientras se cumpla la condición. Por otro lado, el bucle
«para» es: palabra clave, la asignación de una nueva variable (que no es
necesario declarar de forma explícita) a su valor inicial, una flecha y el valor
final (no inclusivo) que tendrá la variable. Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
mientras a || b && !c {
    //Codigo

    para i = 0 -> 20 {
        //Codigo anidado
    }
}
    \end{lstlisting}
    \caption{Ejemplo de bucles (anidados).}
\end{figure}

\section*{Gestión de errores}
Para la gestión de errores, el compilador simplemente imprimirá el tipo de error
que se ha dado y su localización en el fichero de texto. No habrá recuperación
de errores).
