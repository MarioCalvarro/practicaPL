\chapter*{Requisitos}
En esa sección daremos los detalles sobre la sintaxis de nuestro lenguaje. La
dividiremos en varias secciones siguiendo el enunciado de la práctica. En primer
lugar, debemos recalcar que todas las sentencias del lenguaje acaban con puntos
y coma y los comentarios pueden ser unilínea (usando //) o multilínea (usando /*
*/). También es importante clarificar que la extensión de los ficheros de este
lenguaje será «.jaja».
\section*{Identificadores y ámbitos de definición}
A la hora de declarar una nueva variable debemos indicar el tipo de la misma y
su identificador, acabando en punto y coma. Respecto a los arrays,
permitiremos la creación de arrays de dimensión arbitraria cuyo tamaño puede
venir dado en tiempo de ejecución por una variable o en compilación de forma
constante. La sintaxis declarar estos arrays será el tipo de los elementos del
array, seguido de el identificador del mismo y corchetes que abren y cierran.
Cada pareja de corchetes indicará una dimensión más.
Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
ent id;
ent arr1[];
ent arr2[][];
    \end{lstlisting}
    \caption{Ejemplo de declaración de variables y arrays de una y dos
    dimensiones.}
\end{figure}

Los bloques anidados simplemente serán delimitados por llaves, por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
si {
    mientras condicion {
        //Codigo
    }
}
    \end{lstlisting}
    \caption{Ejemplo de bloques anidados con un condicional y un bucle.}
\end{figure}

Las funciones se componen de cinco partes diferenciadas. Primero, declaramos que
es una función a través de la palabra clave «diver» (que proviene de la palabra
inglesa \textit{fun} (\textit{function})). Tras esto, incluimos el nombre que se
le da a la función seguido de los argumentos, separados por flechas. Estos
argumentos tendrán la siguiente forma: identificador del parámetro y su tipo.
Finalmente, a través de una flecha indicamos el tipo de retorno de la función y
entre corchetes el cuerpo de la misma. El tipo de retorno es opcional en el caso
de que únicamente se modifique el estado del programa. Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
diver jubilo (a: ent -> b: ent) -> ent {
    //Codigo
}
    \end{lstlisting}
    \caption{Ejemplo de la función \textit{jubilo}, que recibe dos enteros y
    devuelve otro.}
\end{figure}

Hemos decidido incluir en nuestro lenguaje tanto punteros como registros. La
declaración de los punteros la realizaremos similarmente a la de las variables,
pero incluyendo el símbolo (@) entre el tipo y el identificador. Respecto a los
registros se hace de manera similar a las variables habituales, pero añadiendo
la palabra clave «registro» en primer lugar. Se asume que este tipo de datos ha
sido definido correctamente con anterioridad. Estos datos se definen de la
siguiente manera: en primer lugar, utilizamos la palabra clave «registro»,
seguido del nombre de este nuevo tipo. Tras esto, iniciamos un bloque anidado
con los campos del registro y su tipo, separados por comas (el último también
puede tener coma al final de forma opcional). Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
registro datos {
    a: ent,
    b: bin,
}

entero @ p;
registro datos reg;
    \end{lstlisting}
    \caption{Ejemplo de la declaración de un puntero a un entero y de un
    registro con dos campos.}
\end{figure}

Para importar código procedente de otros ficheros utilizamos la palabra clave
«\#traficar» seguido de la localización del otro fichero. Por ejemplo,
\begin{figure}[H]
    \centering
    \begin{lstlisting}
#traficar ruta/a/fichero.jaja
    \end{lstlisting}
    \caption{Ejemplo de la declaración de un puntero a un entero y de un
    registro con dos campos.}
\end{figure}

\section*{Tipos}
Como ya hemos indicado anteriormente, las variables tienen que venir declaradas
de forma explícita y su tipado es estático. Los tipos predefinidos del lenguaje
serán los «enteros» y los «binarios» (booleanos). La lista de operadores
predefinidos será la siguiente (el orden en que aparecen en la lista indica la
prioridad siendo el primero el más prioritario, pero siendo los paréntesis lo
más prioritario de todo).
\begin{itemize}
\item Operadores aritméticos:
    \begin{enumerate}
        \item Potenciación (\^{}).
        \item Producto (*), división (/) y módulo (\%).
        \item Suma (*) y división (-).
    \end{enumerate}
\end{itemize}
